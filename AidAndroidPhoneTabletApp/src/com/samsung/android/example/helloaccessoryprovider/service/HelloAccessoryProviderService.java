/*     * Copyright (c) 2014 Samsung Electronics Co., Ltd.    * All rights reserved.    *    * Redistribution and use in source and binary forms, with or without    * modification, are permitted provided that the following conditions are    * met:    *    *     * Redistributions of source code must retain the above copyright    *        notice, this list of conditions and the following disclaimer.   *     * Redistributions in binary form must reproduce the above   *       copyright notice, this list of conditions and the following disclaimer   *       in the documentation and/or other materials provided with the   *       distribution.   *     * Neither the name of Samsung Electronics Co., Ltd. nor the names of its   *       contributors may be used to endorse or promote products derived from   *       this software without specific prior written permission.   *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package com.samsung.android.example.helloaccessoryprovider.service;import java.io.ByteArrayInputStream;import java.io.IOException;import java.security.cert.CertificateException;import java.security.cert.CertificateFactory;import java.util.Date;import java.util.HashMap;import javax.security.cert.X509Certificate;import org.json.JSONObject;import us.gpop.aid.AidApp;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.SharedPreferences;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import android.content.pm.PackageManager.NameNotFoundException;import android.content.pm.Signature;import android.os.Binder;import android.os.IBinder;import android.text.format.Time;import android.util.Log;import android.view.Gravity;import android.widget.Toast;import com.samsung.android.sdk.SsdkUnsupportedException;import com.samsung.android.sdk.accessory.SA;import com.samsung.android.sdk.accessory.SAAgent;import com.samsung.android.sdk.accessory.SAAuthenticationToken;import com.samsung.android.sdk.accessory.SAPeerAgent;import com.samsung.android.sdk.accessory.SASocket;public class HelloAccessoryProviderService extends SAAgent {	public static final String TAG = "HelloAccessoryProviderService";		public Boolean isAuthentication = false;	public static final int SERVICE_CONNECTION_RESULT_OK = 0;	public static final int HELLOACCESSORY_CHANNEL_ID = 104;	HashMap<Integer, HelloAccessoryProviderConnection> mConnectionsMap = null;	private final IBinder mBinder = new LocalBinder();	private int authCount = 1;	public class LocalBinder extends Binder {		public HelloAccessoryProviderService getService() {			return HelloAccessoryProviderService.this;		}	}	public HelloAccessoryProviderService() {		super(TAG, HelloAccessoryProviderConnection.class);	}	public class HelloAccessoryProviderConnection extends SASocket {		private int mConnectionId;		public HelloAccessoryProviderConnection() {			super(HelloAccessoryProviderConnection.class.getName());		}		@Override		public void onError(int channelId, String errorString, int error) {		}		@Override		public void onReceive(int channelId, byte[] data) {			Time time = new Time();			time.set(System.currentTimeMillis());			String timeStr = " " + String.valueOf(time.minute) + ":"					+ String.valueOf(time.second);			String strToUpdateUI = new String(data);						final String message = strToUpdateUI.concat(timeStr);			onReceivedMessageFromWatch(message);						final HelloAccessoryProviderConnection uHandler = mConnectionsMap.get(Integer					.parseInt(String.valueOf(mConnectionId)));			if(uHandler == null){				return;			}			new Thread(new Runnable() {				public void run() {					try {						uHandler.send(HELLOACCESSORY_CHANNEL_ID, message.getBytes());					} catch (IOException e) {						e.printStackTrace();					}				}			}).start();		}		@Override		protected void onServiceConnectionLost(int errorCode) {			if (mConnectionsMap != null) {				mConnectionsMap.remove(mConnectionId);			}		}	}		private void onReceivedMessageFromWatch(final String message) {		Toast.makeText(getApplicationContext(), 				"Data from watch: " + message, Toast.LENGTH_LONG).show();		try {			// Read number of steps			JSONObject parsedJsonDataFromWatch = new JSONObject(message);			if (!parsedJsonDataFromWatch.has("totalStep")) {				Log.e("AidAccessoryService", "no steps from data from watch");				return;							}							final int steps = parsedJsonDataFromWatch.getInt("totalStep");			final Toast toast = Toast.makeText(getApplicationContext(), 					"Steps from watch: " + steps, Toast.LENGTH_LONG);			toast.setGravity(Gravity.TOP, 0, 0);			toast.show();						if (!parsedJsonDataFromWatch.has("heartRate")) {				Log.e("AidAccessoryService", "no heart rate sent");			} else {				Log.e("AidAccessoryService", "heartRate: " + parsedJsonDataFromWatch.getInt("heartRate"));			}						// Find chart to add to			final String chartName = AidApp.getInstance().getCurrentChartName();						if (null == chartName) {				Log.e("AidAccessoryService", "no current chart");				return;							} else {				Log.e("AidAccessoryService", "adding data to chart: " + chartName);							}						// ANDROID WEAR PEDOMETER CODE		    // PREFERENCES		    SharedPreferences AID_prefs; // SharedPreferences objects that store settings for the application.		    SharedPreferences.Editor AID_prefs_editor; // SharedPreferences.Editor objects that are used for editing the temporary preferences.		    final String AID_OPTIONS = "aid_pref"; // Used to reference the name of the preference XML file.            String PEDOMETERKEY = "df_pedometer";		                    // Stores the value in preferences.            AID_prefs = getSharedPreferences(AID_OPTIONS, MODE_PRIVATE); // Main preferences variable.            AID_prefs_editor = AID_prefs.edit();            int pedValues = AID_prefs.getInt(PEDOMETERKEY, 0); // Gets the retrieved integer value.            Boolean isWearDataReceived = AID_prefs.getBoolean("df_isWearDataSent", false); // Checks to see if wear sent data.            Log.d(TAG, "PEDOMETER VALUE: " + pedValues); // LOGGING			            // Transmits Wear data.            if (isWearDataReceived) {    			JSONObject chartDataPoint = new JSONObject();    			chartDataPoint.put("steps", pedValues);    			chartDataPoint.put("timestamp", new Date().getTime());    			JSONObject createdRecord = AidApp.getInstance().store.create(chartName, chartDataPoint);    			Log.i("AidAccessoryService", "inserted data from ANDROID WEAR into SmartStore: " + createdRecord);    			                AID_prefs_editor = AID_prefs.edit();                AID_prefs_editor.putInt(PEDOMETERKEY, 0); // Stores the retrieved integer value.                AID_prefs_editor.putBoolean("df_isWearDataSent", false); // Resets value.            }						Log.i("AidAccessoryService", "calling create");			JSONObject chartDataPoint = new JSONObject();			chartDataPoint.put("steps", steps);			chartDataPoint.put("timestamp", new Date().getTime());			JSONObject createdRecord = AidApp.getInstance().store.create(chartName, chartDataPoint);			Log.i("AidAccessoryService", "inserted data from watch into SmartStore: " + createdRecord);									final Intent updateIntent = new Intent(AidApp.STEPS_RECEIVED_INTENT_ACTION);			sendBroadcast(updateIntent);			Log.i("AidAccessoryService", "send update broadcast");					} catch(Throwable t) {			throw new RuntimeException("Error parsing JSON message from watch", t);		}	}    @Override    public void onCreate() {        super.onCreate();                SA mAccessory = new SA();        try {        	mAccessory.initialize(this);        } catch (SsdkUnsupportedException e) {        	// Error Handling        } catch (Exception e1) {            e1.printStackTrace();			/*			 * Your application can not use Accessory package of Samsung			 * Mobile SDK. You application should work smoothly without using			 * this SDK, or you may want to notify user and close your app			 * gracefully (release resources, stop Service threads, close UI			 * thread, etc.)			 */            stopSelf();        }    }	        @Override     protected void onServiceConnectionRequested(SAPeerAgent peerAgent) {    	/*    	* The authenticatePeerAgent(peerAgent) API may not be working properly     	* depending on the firmware version of accessory device.         * Recommend to upgrade accessory device firmware if possible.        */     	//    	if(authCount%2 == 1)//    		isAuthentication = false;//    	else//    		isAuthentication = true; //    	authCount++;    	    	isAuthentication = false;    	    	if(isAuthentication) {            Toast.makeText(getBaseContext(), "Authentication On!", Toast.LENGTH_SHORT).show();            authenticatePeerAgent(peerAgent);        }    	else {            Toast.makeText(getBaseContext(), "Authentication Off!", Toast.LENGTH_SHORT).show();            acceptServiceConnectionRequest(peerAgent);        }    		    }         protected void onAuthenticationResponse(SAPeerAgent uPeerAgent,    		SAAuthenticationToken authToken, int error) {				if (authToken.getAuthenticationType() == SAAuthenticationToken.AUTHENTICATION_TYPE_CERTIFICATE_X509) {			byte[] myAppKey = getApplicationCertificate(getApplicationContext());					if (authToken.getKey() != null) {				boolean matched = true;				if(authToken.getKey().length != myAppKey.length){					matched = false;				}else{					for(int i=0; i<authToken.getKey().length; i++){						if(authToken.getKey()[i]!=myAppKey[i]){							matched = false;						}					}				}								if (matched) {					acceptServiceConnectionRequest(uPeerAgent);				}							}		} else if (authToken.getAuthenticationType() == SAAuthenticationToken.AUTHENTICATION_TYPE_NONE) 			Log.e(TAG, "onAuthenticationResponse : CERT_TYPE(NONE)");			}		private static byte[] getApplicationCertificate(Context context) {		if(context == null) {			return null;		}		Signature[] sigs;		byte[] certificat = null;		String packageName = context.getPackageName();		if (context != null) {			try {				PackageInfo pkgInfo = null;				pkgInfo = context.getPackageManager().getPackageInfo(						packageName, PackageManager.GET_SIGNATURES);				if (pkgInfo == null) {					return null;				}				sigs = pkgInfo.signatures;				if (sigs == null) {				} else {					CertificateFactory cf = CertificateFactory							.getInstance("X.509");					ByteArrayInputStream stream = new ByteArrayInputStream(							sigs[0].toByteArray());					X509Certificate cert;					cert = X509Certificate.getInstance(stream);					certificat = cert.getPublicKey().getEncoded();				}			} catch (NameNotFoundException e) {				// TODO Auto-generated catch block				e.printStackTrace();			} catch (CertificateException e) {				// TODO Auto-generated catch block				e.printStackTrace();			} catch (javax.security.cert.CertificateException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}		}		return certificat;	}    	@Override	protected void onFindPeerAgentResponse(SAPeerAgent arg0, int arg1) {		// TODO Auto-generated method stub	}	@Override	protected void onServiceConnectionResponse(SAPeerAgent peerAgent, SASocket thisConnection,			int result) {		if (result == CONNECTION_SUCCESS) {						if (thisConnection != null) {				HelloAccessoryProviderConnection myConnection = (HelloAccessoryProviderConnection) thisConnection;				if (mConnectionsMap == null) {					mConnectionsMap = new HashMap<Integer, HelloAccessoryProviderConnection>();				}				myConnection.mConnectionId = (int) (System.currentTimeMillis() & 255);				mConnectionsMap.put(myConnection.mConnectionId, myConnection);			} 		}		else if (result == CONNECTION_ALREADY_EXIST) {			Log.e(TAG, "onServiceConnectionResponse, CONNECTION_ALREADY_EXIST");		}	}	@Override	public IBinder onBind(Intent arg0) {		return mBinder;	}}